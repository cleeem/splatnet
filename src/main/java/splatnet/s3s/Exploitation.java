package splatnet.s3s;

import com.google.gson.*;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import splatnet.s3s.classes.game.Player;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.*;

public class Exploitation {

    public static String customQuery(String gtoken, String key, String dicthKey2, String dictValue) {
        String sha = Utils.translateRid.get(key);

        String data = Utils.genGraphqlBody(sha, dicthKey2, dictValue);

        HashMap<String, String> headers = UtilitaryS3S.headbutt("en-US");

        HashMap<String, String> params = new HashMap<>();
        params.put("_gtoken", gtoken);

        String response = null;
        try {
            response = Jsoup.connect(Iksm.GRAPHQL_URL)
                    .headers(headers)
                    .data(params)
                    .requestBody(data)
                    .ignoreContentType(true)
                    .post()
                    .body()
                    .text();

        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        return response;
    }

    public static String homeQuery(String gtoken) {
        String sha = Utils.translateRid.get("HomeQuery");

        String data = Utils.genGraphqlBody(sha, "naCountry", UtilitaryS3S.userCountry);

        HashMap<String, String> headers = UtilitaryS3S.headbutt("en-US");

        HashMap<String, String> params = new HashMap<>();
        params.put("_gtoken", gtoken);

        String response = null;
        try {
            response = Jsoup.connect(Iksm.GRAPHQL_URL)
                    .headers(headers)
                    .data(params)
                    .requestBody(data)
                    .ignoreContentType(true)
                    .post()
                    .body()
                    .text();

        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        return response;
    }

    public static JsonArray fetchFriendList(String gtoken) {
        String sha = Utils.translateRid.get("FriendListQuery");

        String data = Utils.genGraphqlBody(sha, null, null);

        HashMap<String, String> headers = UtilitaryS3S.headbutt("en-US");

        HashMap<String, String> params = new HashMap<>();
        params.put("_gtoken", gtoken);

        String response = null;

        JsonArray friendList = null;

        try {
            response = Jsoup.connect(Iksm.GRAPHQL_URL)
                    .headers(headers)
                    .data(params)
                    .requestBody(data)
                    .ignoreContentType(true)
                    .post()
                    .body()
                    .text();

            friendList = JsonParser.parseString(response).getAsJsonObject().get("data").getAsJsonObject()
                    .get("friends").getAsJsonObject().get("nodes").getAsJsonArray();

        } catch (IOException e) {
            throw new RuntimeException(e);
        }


        return friendList;

    }

    private static ArrayList<String> fetchBattlesData(String gtoken, int limit, ArrayList<String> battlesIds) {
        String sha = Utils.translateRid.get("VsHistoryDetailQuery");

        String secondKey = "vsResultId";

        HashMap<String, String> headers = UtilitaryS3S.headbutt("en-US");

        HashMap<String, String> params = new HashMap<>();
        params.put("_gtoken", gtoken);

        if (battlesIds.size() < limit) {
            limit = battlesIds.size();
        }

        List<String> sub = battlesIds.subList(0, limit);

        ArrayList<Future<String>> futures = new ArrayList<>();

        // Create a pool of threads
        ExecutorService executor = Executors.newFixedThreadPool(limit);

        for (String id : sub) {
            String data = Utils.genGraphqlBody(sha, secondKey, id);

            // Submit a new task for each id
            futures.add(executor.submit(() -> {
                try {
                    Document response = Jsoup.connect(Iksm.GRAPHQL_URL)
                            .headers(headers)
                            .data(params)
                            .requestBody(data)
                            .ignoreContentType(true)
                            .post();

                    return response.body().text();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }));

        }

        ArrayList<String> returnData = new ArrayList<>();

        // Get the result of each task
        for (Future<String> future : futures) {
            try {
                returnData.add(future.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }

        // Shutdown the executor
        executor.shutdown();

        return returnData;
    }

    public static ArrayList<String> parseVsHistory(String gtoken, String key, int limitArg) {

        int limit = 1;

        if ( 1 <= limitArg && limitArg <= 50) {
            limit = limitArg;
        }

        ArrayList<String> queriesToRun = getQueriesToRun(key);

        ArrayList<String> battlesIds = getVsIds(gtoken, queriesToRun);

        ArrayList<String> returnData = fetchBattlesData(gtoken, limit, battlesIds);

        return returnData;
    }

    public static ArrayList<String> parseBattlesHistory(String gToken, String key, int limitArg) {
        int limit = 1;

        if ( 1 <= limitArg && limitArg <= 50) {
            limit = limitArg;
        }

        ArrayList<String> queriesToRun = new ArrayList<String>();
        queriesToRun.add(key);

        ArrayList<String> battlesIds = getVsBattlesIds(gToken, queriesToRun);

        ArrayList<String> returnData = fetchBattlesData(gToken, limit, battlesIds);

        return returnData;
    }

    private static ArrayList<String> getVsBattlesIds(String gToken, ArrayList<String> queriesToRun) {
        ArrayList<String> battlesIds = new ArrayList<>();

        JsonArray battleGroup = null;
        String id = null;

        for (String hash : queriesToRun) {
            String query = Utils.translateRid.get(hash);

            String trimedHash = getValidName(hash);

            try {
                String response = Jsoup.connect(Iksm.GRAPHQL_URL)
                        .headers(UtilitaryS3S.headbutt("en-US"))
                        .data("_gtoken", gToken)
                        .requestBody(Utils.genGraphqlBody(query, null, null))
                        .ignoreContentType(true)
                        .post()
                        .body()
                        .text();

                JsonObject data = JsonParser.parseString(response).getAsJsonObject().get("data").getAsJsonObject();
                JsonObject lattestBattleHistories = data.get(trimedHash).getAsJsonObject();
                JsonObject historyGroups = lattestBattleHistories.get("historyGroups").getAsJsonObject();
                JsonArray nodes1 = historyGroups.get("nodes").getAsJsonArray();


                for (JsonElement battle : nodes1) {
                    JsonObject temp = battle.getAsJsonObject();
                    JsonArray batt;
                    batt = temp.get("historyDetails").getAsJsonObject().get("nodes").getAsJsonArray();

                    for (JsonElement b : batt) {
                        battlesIds.add(b.getAsJsonObject().get("id").getAsString());
                    }
                }


            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        return battlesIds;
    }

    private static String getValidName(String hash) {
        switch (hash) {
            case "RegularBattleHistoriesQuery":
                return "regularBattleHistories";

            case "BankaraBattleHistoriesQuery":
                return "bankaraBattleHistories";

            case "XBattleHistoriesQuery":
                return "xBattleHistories";

            case "EventBattleHistoriesQuery":
                return "eventBattleHistories";

            case "PrivateBattleHistoriesQuery":
                return "privateBattleHistories";

            default:
                return "latestBattleHistories";
        }
    }

    private static ArrayList<String> getVsIds(String gtoken, ArrayList<String> queriesToRun) {
        ArrayList<String> battlesIds = new ArrayList<>();

        JsonArray battleGroup = null;
        String id = null;

        for (String hash : queriesToRun) {
            String query = Utils.translateRid.get(hash);

            try {
                String response = Jsoup.connect(Iksm.GRAPHQL_URL)
                        .headers(UtilitaryS3S.headbutt(null))
                        .data("_gtoken", gtoken)
                        .requestBody(Utils.genGraphqlBody(query, null, null))
                        .ignoreContentType(true)
                        .post()
                        .body()
                        .text();

                battleGroup = JsonParser.parseString(response).getAsJsonObject().get("data").getAsJsonObject()
                                                                         .get("latestBattleHistories").getAsJsonObject()
                                                                         .get("historyGroups").getAsJsonObject()
                                                                         .get("nodes").getAsJsonArray();

                for (JsonElement battle : battleGroup) {
                    JsonObject temp = battle.getAsJsonObject();
                    JsonArray batt;
                    batt = temp.get("historyDetails").getAsJsonObject().get("nodes").getAsJsonArray();

                    for (JsonElement b : batt) {
                        battlesIds.add(b.getAsJsonObject().get("id").getAsString());
                    }
                }


            } catch (IOException e) {
                throw new RuntimeException(e);
            }

        }

        return battlesIds;
    }

    private static ArrayList<String> getQueriesToRun(String key) {
        ArrayList<String> queriesToRun = new ArrayList<>();

        switch (key) {
            case "regular":
                queriesToRun.add("RegularBattleHistoriesQuery");
                break;
            case "anarchy":
                queriesToRun.add("BankaraBattleHistoriesQuery");
                break;
            case "x":
                queriesToRun.add("XBattleHistoriesQuery");
                break;
            case "challenge":
                queriesToRun.add("EventBattleHistoriesQuery");
                break;
            case "private":
                queriesToRun.add("PrivateBattleHistoriesQuery");
                break;
            default:
                queriesToRun.add("LatestBattleHistoriesQuery");
                break;
        }

        return queriesToRun;
    }

    public static void test(String gtoken) {
        try {
            String sha = Utils.translateRid.get("HomeQuery");
            String data = Utils.genGraphqlBody(sha, "naCountry", UtilitaryS3S.userCountry);
            HashMap<String, String> headers = UtilitaryS3S.headbutt(null);
            HashMap<String, String> params = new HashMap<>();
            params.put("_gtoken", gtoken);

            try {
                Jsoup.connect(Iksm.GRAPHQL_URL)
                     .headers(headers)
                     .data(params)
                     .requestBody(data)
                     .ignoreContentType(true)
                     .post();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static HashMap<String, String> getXPowers(String gtoken) {

        String key = "XBattleHistoriesQuery";

        try {
            String sha = Utils.translateRid.get(key);
            String data = Utils.genGraphqlBody(sha, null, null);
            HashMap<String, String> headers = UtilitaryS3S.headbutt(null);
            HashMap<String, String> params = new HashMap<>();
            params.put("_gtoken", gtoken);

            String response = Jsoup.connect(Iksm.GRAPHQL_URL)
                    .headers(headers)
                    .data(params)
                    .requestBody(data)
                    .ignoreContentType(true)
                    .post()
                    .body()
                    .text();

            JsonObject dataJson = JsonParser.parseString(response).getAsJsonObject().get("data").getAsJsonObject()
                    .get("xBattleHistories").getAsJsonObject().get("summary").getAsJsonObject();

            HashMap<String, String> xPowers = new HashMap<>();
            xPowers.put("zones", dataJson.get("xPowerAr").getAsJsonObject().get("lastXPower").getAsString());
            xPowers.put("tower", dataJson.get("xPowerLf").getAsJsonObject().get("lastXPower").getAsString());
            xPowers.put("rainmaker", dataJson.get("xPowerGl").getAsJsonObject().get("lastXPower").getAsString());
            xPowers.put("clam", dataJson.get("xPowerCl").getAsJsonObject().get("lastXPower").getAsString());

            return xPowers;

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static Player historyQuery(String gtoken) {
        String key = "HistoryRecordQuery";

        String response;
        try {
            String sha = Utils.translateRid.get(key);
            String data = Utils.genGraphqlBody(sha, null, null);
            HashMap<String, String> headers = UtilitaryS3S.headbutt("en-US");
            HashMap<String, String> params = new HashMap<>();
            params.put("_gtoken", gtoken);

            response = Jsoup.connect(Iksm.GRAPHQL_URL)
                    .headers(headers)
                    .data(params)
                    .requestBody(data)
                    .ignoreContentType(true)
                    .post()
                    .body()
                    .text();

            JsonObject dataJson = JsonParser.parseString(response).getAsJsonObject();
            return new Player(dataJson.getAsJsonObject("data").getAsJsonObject("currentPlayer"));

        } catch (IOException e) {
            throw new RuntimeException(e);
        }

    }
}
